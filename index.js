var _ = require('lodash');
var Temporal = function(model, sequelize, temporalOptions){

  var temporalDefaultOptions = {
    // runs the insert within the sequelize hook chain, disable
    // for increased performance
    blocking: true 
  };

  temporalOptions = _.extend({},temporalDefaultOptions, temporalOptions);

  var Sequelize = sequelize.Sequelize;

  //var historyName = model.name + 'History';
  var historyName = model.getTableName() + 'History';
  //var historyName = model.options.name.singular + 'History';

  var historyOwnOptions = {
    timestamps: false
  };
  var historyOptions = _.assign({}, model.options, historyOwnOptions);
  delete historyOptions.name;
  delete historyOptions.sequelize;

  var historyOwnAttrs = {
    hid: {
      type:          Sequelize.BIGINT,
      primaryKey:    true,
      autoIncrement: true,
      unique: true
    },
    archivedAt: {
      type: Sequelize.DATE,
      allowNull: false,
      defaultValue: Sequelize.NOW
    }
  };

  var historyAttributes = _(model.rawAttributes).omit(function(v){
    //if(_.has(v,'_autoGenerated')){
  }).mapValues(function(v){
    var v = _.extend({}, v);
    delete v.Model;
    // remove all uniqueness, primary and 
    delete v.unique;
    delete v.primaryKey;
    delete v.autoIncrement;
    if(v.fieldName == "createdAt" || 
       v.fieldName == "updatedAt"){
         v.type = Sequelize.DATE;
       }
       return v
  }).assign(historyOwnAttrs).value();
  // If the order matters, use this:
  //historyAttributes = _.assign({}, historyOwnAttrs, historyAttributes);

  var modelHistory = sequelize.define(historyName, historyAttributes, historyOptions);

  // we already get the updatedAt timestamp from our models
  var insertHook = function(obj, options){
    var historyRecord = modelHistory.create(obj.dataValues, {transaction: options.transaction});
    if(temporalOptions.blocking){
      return historyRecord;
    }
  }
  var insertBulkHook = function(options){
    if(!options.individualHooks){
      var queryAll = model.findAll({where: options.where, transaction: options.transaction}).then(function(hits){
        if(hits){
          hits = _.pluck(hits, 'dataValues');
          return modelHistory.bulkCreate(hits, {transaction: options.transaction});
        }
      });
      if(temporalOptions.blocking){
        return queryAll;
      }
    }
  }

  // use `after` to be nonBlocking
  // all hooks just create a copy
  model.hook('beforeUpdate', insertHook);
  model.hook('beforeDestroy', insertHook);

  model.hook('beforeBulkUpdate', insertBulkHook);
  model.hook('beforeBulkDestroy', insertBulkHook);

  // TODO: handle bulk operations

  var readOnlyHook = function(){
    console.log("read-only");
    throw new Error("This is a read-only history database. You aren't allowed to modify it.");    
  }

  modelHistory.hook('beforeUpdate', readOnlyHook);
  modelHistory.hook('beforeDestroy', readOnlyHook);

  return model;
};

module.exports = Temporal;
